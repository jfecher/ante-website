<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ante</title>
    <link>https://antelang.org/</link>
    <description>Recent content on Ante</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://antelang.org/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Avoiding Lifetime Variables</title>
      <link>https://antelang.org/blog/second_class_references/</link>
      <pubDate>Tue, 30 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://antelang.org/blog/second_class_references/</guid>
      <description>Introduction  (yet to be written)</description>
    </item>
    
    <item>
      <title>Achieving Safe, Aliasable Mutability with Unboxed Types</title>
      <link>https://antelang.org/blog/safe_shared_mutability/</link>
      <pubDate>Mon, 29 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://antelang.org/blog/safe_shared_mutability/</guid>
      <description>This is part of Ante&amp;rsquo;s goal of loosening restrictions on low-level programming while remaining fast, memory-safe, and thread-safe.
 Background  When writing low-level, memory-safe, and thread-safe programs, a nice feature that lets us achieve all of these is an ownership model. Ownership models have been used by quite a few languages, but the language which popularized them was Rust. In Rust, the compiler will check our code to ensure we have no dangling references and cannot access already-freed memory (among other errors).</description>
    </item>
    
    <item>
      <title>Roadmap</title>
      <link>https://antelang.org/docs/roadmap/</link>
      <pubDate>Sat, 25 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://antelang.org/docs/roadmap/</guid>
      <description>This page is for an in-depth roadmap of ante to show what is currently implemented in the compiler. Note that the basic compiler passes from lexing, parsing, etc through (llvm) codegen have been implemented for quite some time so readers can assume the basic inner workings of the compiler are working.
All designs in the ideas page are not implemented as their design is still non-final and may not be selected at all.</description>
    </item>
    
    <item>
      <title>Ideas</title>
      <link>https://antelang.org/docs/ideas/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://antelang.org/docs/ideas/</guid>
      <description>This page is an incomplete list of features that are currently being considered for ante but for one reason or another are not included in the language already. These features are listed in no particular order.
 Derive Without Macros Trait deriving is an extremely useful feature for any language with traits and trait impls. It cuts down on so much boilerplate that I would even argue it to be necessary.</description>
    </item>
    
    <item>
      <title>Language Tour</title>
      <link>https://antelang.org/docs/language/</link>
      <pubDate>Mon, 01 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://antelang.org/docs/language/</guid>
      <description>Ante is a low-level impure functional programming language. It is low-level in the sense that types are not boxed by default and programmers can still delve down to optimize allocation/representation of memory if desired. A central goal of ante however, is to not force this upon users and provide sane defaults where possible. Compared to other low-level languages, ante is safe like rust but tries to be easier in general, for example by avoiding the need for ownership semantics through lifetime inference.</description>
    </item>
    
  </channel>
</rss>
