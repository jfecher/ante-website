<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
<meta name="robots" content="all,follow">
<meta name="googlebot" content="index,follow,snippet,archive">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Achieving Safe, Aliasable Mutability with Unboxed Types</title>
<meta name="author" content="jfecher" />




<meta name="keywords" content="ante, programming, language, antelang, lang">


<meta name="description" content="">

<meta name="generator" content="Hugo 0.89.0-DEV" />


<link href='//fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,500,700,800' rel='stylesheet' type='text/css'>


<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.11.2/css/all.css">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link href="/css/animate.css" rel="stylesheet">



  <link href="/css/style.red.css" rel="stylesheet" id="theme-stylesheet">



<link href="/css/custom.css" rel="stylesheet">



  <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->



<link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
<link rel="apple-touch-icon" href="/img/apple-touch-icon.png" />


<link href="/css/owl.carousel.css" rel="stylesheet">
<link href="/css/owl.theme.css" rel="stylesheet">


<link rel="alternate" href="https://antelang.org/index.xml" type="application/rss+xml" title="Ante">








<meta property="og:locale" content="en_us">
<meta property="og:site_name" content="Ante">
<meta property="og:title" content="Achieving Safe, Aliasable Mutability with Unboxed Types">
<meta property="og:type" content="article">
<meta property="og:url" content="https://antelang.org/blog/safe_shared_mutability/" />
<meta property="og:description" content="">
<meta property="og:image" content="https://antelang.org/img/banners/antelope_bird.jpg">
<meta property="og:image:type" content="image/jpg">



  <meta property="og:image:width" content="960">
  <meta property="og:image:height" content="640">


<meta property="og:updated_time" content="2024-01-29T00:00:00Z">

  
  
  <meta property="article:section" content="mutability">
  
  
  <meta property="article:published_time" content="2024-01-29T00:00:00Z">
  <meta property="article:modified_time" content="2024-01-29T00:00:00Z">



<meta name="twitter:card" content="summary_large_image">

<meta name="twitter:title" content="Achieving Safe, Aliasable Mutability with Unboxed Types">

<meta name="twitter:image" content="https://antelang.org/img/banners/antelope_bird.jpg">

<meta name="twitter:description" content="">


      <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Achieving Safe, Aliasable Mutability with Unboxed Types</title>
  <meta name="author" content="" />

  <meta name="keywords" content="ante, programming, language, antelang, lang">	
  <meta name="description" content="For exploring refinement types, lifetime inference, and algebraic effects">

  <meta name="generator" content="Hugo 0.89.0-DEV" />

  <link href='//fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,500,700,800' rel='stylesheet' type='text/css'>

  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  
  <link href="https://antelang.org/css/animate.css" rel="stylesheet">

  
  
    <link href="https://antelang.org/css/style.red.css" rel="stylesheet" id="theme-stylesheet">
  


  
  <link href="https://antelang.org/css/custom.css" rel="stylesheet">
 
  
  <link rel="stylesheet" href="https://antelang.org/css/syntax.css">

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="https://antelang.org/img/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" href="https://antelang.org/img/apple-touch-icon.png" />
  

  <link href="https://antelang.org/css/owl.carousel.css" rel="stylesheet">
  <link href="https://antelang.org/css/owl.theme.css" rel="stylesheet">

  <link rel="alternate" href="https://antelang.org/index.xml" type="application/rss+xml" title="Ante">

  
  <meta property="og:title" content="Achieving Safe, Aliasable Mutability with Unboxed Types" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://antelang.org/blog/safe_shared_mutability//" />
  <meta property="og:image" content="" />

  </head>

  <body>

    <div id="all">

        


        

    <div class="navbar navbar-default yamm" role="navigation" id="navbar">

        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="https://antelang.org/">
                    <img src="https://antelang.org/img/ante_white.svg" width="90rem" alt="Achieving Safe, Aliasable Mutability with Unboxed Types" class="hidden-xs hidden-sm">
                    <img src="https://antelang.org/img/ante_white.svg" width="90rem" alt="Achieving Safe, Aliasable Mutability with Unboxed Types" class="visible-xs visible-sm">
                    <span class="sr-only">Achieving Safe, Aliasable Mutability with Unboxed Types - go to homepage</span>
                </a>
                
<div class="navbar-buttons">
        <div class="navbar-collapse collapse" id="navigation">
            <ul class="nav navbar-nav navbar-right">
            
            <li class="dropdown">
                <a href="https://antelang.org/">Home</a>
            </li>
            <li class="dropdown">
                <a href="https://antelang.org//docs/language">Documentation</a>
            </li>
            <li class="dropdown">
                <a href="https://antelang.org//docs/ideas">Ideas</a>
            </li>
            <li class="dropdown">
                <a href="https://antelang.org//docs/roadmap">Roadmap</a>
            </li>
            <li class="dropdown">
                <a href="https://antelang.org//blog">Blog</a>
            </li>
            </ul>
        </div>
        <button type="button" class="navbar-toggle btn-template-main" onclick="document.getElementById('navigation').classList.toggle('collapse')">
    <span class="sr-only">Toggle Navigation</span>
        <i class="fa fa-align-justify"></i>
    </button>
</div>

            </div>
            

            
            

            <div class="collapse clearfix" id="search">

                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search">
                        <span class="input-group-btn">

                    <button type="submit" class="btn btn-template-main"><i class="fa fa-search"></i></button>

                </span>
                    </div>
                </form>

            </div>
            

        </div>
    </div>
    






        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>Achieving Safe, Aliasable Mutability with Unboxed Types</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">

                        
                          <p class="text-muted text-uppercase mb-small text-right">
                            
                            
                            
                              
                              
                                  
                              
                                  
                              
                                  
                              
                                  
                              
                                  
                              
                                  
                              
                                  
                              
                                  
                              
                                  
                              
                                  
                              
                                  
                              
                                  
                              
                              
                            
                          </p>
                        

                        <div id="post-content">
                          <p>This is part of Ante&rsquo;s goal of loosening restrictions on low-level programming while remaining
fast, memory-safe, and thread-safe.</p>
<hr>
<h1 id="background">Background</h1>
<hr>
<p>When writing low-level, memory-safe, and thread-safe programs, a nice feature that lets us
achieve all of these is an ownership model. These have been used by quite a few languages,
but the language which popularized ownership was Rust. In Rust, the compiler will check our
code to ensure we have no dangling references and cannot access already-freed memory. For
example, the next snippet is a compile-time error in rust:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">first_element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// Uh-oh, this may reallocate the Vec, making `first_element` a dangling reference!
</span><span class="c1">// Luckily, we get a compile-time error:
</span><span class="c1">// error[E0502]: cannot borrow `vec` as mutable because it is also borrowed as immutable
</span><span class="c1"></span><span class="n">vec</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{first_element}&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>This is great. Those familiar with Rust however, will note that this error is actually caused
by a related feature to ownership: Rust&rsquo;s borrowing rules. It turns out that moving every object
into and out of each function is not very convenient, so Rust also lets us create borrowed
references to values. These references can be mutable or immutable, and their lifetimes are tied
to that of the owned value. This particular error is prevented by Rust&rsquo;s &ldquo;Aliasibility XOR Mutability&rdquo;
rule, which I&rsquo;ll call AxM for short. AxM in Rust states that you can have aliasable borrowed
references, or you can have mutability, but not both. So in the example above, since <code>Vec::push</code>
requires a mutable <code>&amp;mut Vec&lt;i32&gt;</code> reference, we got a compile-time error trying to call it since
we also had the immutably borrowed reference <code>first_elem: &amp;i32</code> in scope. Had we not printed
<code>first_element</code> out afterward, it could be dropped earlier and the code would work, but as-is
we rightfully get an error.</p>
<p>This is a great thing to prevent, but it is unfortunate that AxM errors are some of the most common
errors in Rust and make the language more difficult to learn when they are run into so often. As
someone who has been writing Rust roughly since 1.0, I think it&rsquo;s fair to say even experienced users
run into AxM errors every now and then. Fixing these often requires excessive cloning or reworking
an algorithm which can be tedious.</p>
<p>Moreover, the issue with AxM is that aliasable mutability isn&rsquo;t actually always dangerous.
Consider the following program:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">my_tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">first_elem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_tuple</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">// error[E0506]: cannot assign to `my_tuple` because it is borrowed
</span><span class="c1"></span><span class="n">my_tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{first_elem}&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>We&rsquo;d get a similar error if <code>my_tuple</code> was a <code>&amp;mut (i32, i32)</code> or if <code>first_elem</code> was a mutable reference, etc.
Why is this? The program is actually perfectly safe. No matter how <code>my_tuple</code> is mutated, its shape
stays stable, and any inner references will not be invalidated. Another thread
mutating the data out from under us in a non-atomic way (a la Java) is also not possible since
<code>&amp;mut</code> references are not <code>Send</code>-able across threads. This is the kind of code new users often try to write in Rust
and are quickly met with their first experiences with the borrow checker. Needless to say, new users encountering
such an error message with such unfamiliar concepts can easily have their patience chipped away at. At
worst, they could even decide to stop learning the language entirely.</p>
<p>All this seems like a big risk for a language when plenty of other languages get by with aliasable mutability
just fine. For example, <a href="https://www.ponylang.io/">Pony</a> is an example of a thread-safe and memory-safe
language with aliasable mutability. The key difference with these languages is that - unlike Rust - they
force all values to be boxed and often have a garbage collector. This means a function like <code>Vec::get</code> which
returns an offset inside of the vector&rsquo;s storage simply isn&rsquo;t possible to write in those languages. It is as
if each vector were a <code>Vec&lt;Rc&lt;T&gt;&gt;</code> and instead of <code>&amp;Rc&lt;T&gt;</code>, their get function returns a cloned <code>Rc&lt;T&gt;</code>. In
reality, Pony uses a tracing garbage collector so there is no cloning going on, but I think this helps to
illustrate the point that each element inside a Vector would itself be an owned pointer. This is why these
languages don&rsquo;t encounter the same issue Rust has with returning a reference to an element in a aliasable
mutable context.</p>
<p>So other languages like Pony allow aliasable mutability but require us to box all values. Rust
lets us unbox most values and obtain references inside objects, but has the AxM restriction.
Can we do better?</p>
<p>In the next section, I&rsquo;m going to explain my approach with Ante in allowing safe, aliasable mutability
in a language similar to Rust. That is, Ante is thread-safe, memory-safe, and uses unboxed values
with move semantics. As a bonus, this scheme is also completely zero-cost.</p>
<hr>
<h1 id="a-new-approach-for-a-new-age">A New Approach for A New Age</h1>
<p>Ante&rsquo;s system for ensuring memory &amp; thread safety uses Rust as a foundation. Anywhere a non-reference
value is seen, it is an owned value. Similarly, anytime <code>&amp;t</code> or <code>&amp;mut t</code> are seen, these are borrowed
references.</p>
<p>The most important change from Rust&rsquo;s system is that in addition to being tagged with whether they
are <code>mut</code>able or not, references are also tagged with whether they are <code>own</code>ed, or whether they
are <code>shared</code> (able to be mutably aliased). For example, when we take multiple mutable references
to the same value, they are all inferred to be shared:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ante" data-lang="ante"><span class="nf">my_tuple</span> <span class="ow">=</span> <span class="k">mut</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nf">elem1</span> <span class="ow">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">my_tuple</span><span class="o">.</span><span class="mi">0</span>
<span class="nf">also_elem1</span> <span class="ow">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">my_tuple</span><span class="o">.</span><span class="mi">0</span>

<span class="nf">print</span> <span class="n">elem1</span>  <span class="c1">// Outputs 1</span>
<span class="nf">print</span> <span class="n">also_elem1</span>  <span class="c1">// Outputs 1</span>
</code></pre></div><p>The type of <code>elem1</code> and <code>also_elem1</code> here is <code>&amp;shared mut I32</code>.</p>
<p>We can also mutate through these shared references:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ante" data-lang="ante"><span class="nf">my_tuple</span> <span class="ow">=</span> <span class="k">mut</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nf">elem1</span> <span class="ow">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">my_tuple</span><span class="o">.</span><span class="mi">0</span>
<span class="nf">also_elem1</span> <span class="ow">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">my_tuple</span><span class="o">.</span><span class="mi">0</span>

<span class="nf">also_elem1</span> <span class="o">:=</span> <span class="mi">3</span>

<span class="nf">print</span> <span class="n">elem1</span>  <span class="c1">// Outputs 3</span>
</code></pre></div><p>This is because unadorned references (<code>&amp;</code> and <code>&amp;mut</code>) are polymorphic in whether they are <code>own</code>ed
or <code>shared</code>. These polymorphic references have the capabilities of <code>shared</code> references since anywhere
a <code>shared</code> reference is valid, an <code>own</code>ed reference would be as well.
This polymorphism comes in handy when returning a reference. If you passed in an
owned reference, you&rsquo;ll get an owned one back. This would not be the case if Ante were designed to use
reference subtyping here instead. Most importantly, this polymorphism allows most code with references
to be written in a familiar style, ignoring the fact that <code>shared</code> or <code>own</code> exist:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ante" data-lang="ante"><span class="nf">evaluate</span> <span class="p">(</span><span class="n">program</span><span class="o">:</span> <span class="o">&amp;</span><span class="kt">Ast</span><span class="p">)</span> <span class="p">(</span><span class="n">context</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="kt">Context</span><span class="p">)</span> <span class="o">:</span> <span class="kt">I32</span> <span class="k">can</span> <span class="kt">Fail</span> <span class="ow">=</span>
    <span class="k">match</span> <span class="n">program</span>
    <span class="o">|</span> <span class="kt">Int</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span>
    <span class="o">|</span> <span class="kt">Var</span> <span class="n">name</span> <span class="ow">-&gt;</span> <span class="n">lookup</span> <span class="n">context</span> <span class="n">name</span>
    <span class="o">|</span> <span class="kt">Add</span> <span class="n">lhs</span> <span class="n">rhs</span> <span class="ow">-&gt;</span> <span class="n">evaluate</span> <span class="n">lhs</span> <span class="n">context</span> <span class="o">+</span> <span class="n">evaluate</span> <span class="n">rhs</span> <span class="n">context</span>
    <span class="o">|</span> <span class="kt">Let</span> <span class="n">name</span> <span class="n">expr</span> <span class="n">body</span> <span class="ow">-&gt;</span>
        <span class="n">expr_value</span> <span class="ow">=</span> <span class="n">evaluate</span> <span class="n">expr</span> <span class="n">context</span>
        <span class="n">define</span> <span class="n">context</span> <span class="n">name</span> <span class="n">expr_value</span>
        <span class="n">evaluate</span> <span class="n">body</span> <span class="n">context</span>
</code></pre></div><p>(<code>can Fail</code> here is an <a href="/docs/language/#algebraic-effects">Algebraic Effect</a>)</p>
<p>How then, does Ante prevent holding onto references of things that may change out from under itself,
such as vector elements or union fields?</p>
<hr>
<h2 id="preventing-borrows-when-a-types-shape-is-not-stable">Preventing borrows when a type&rsquo;s shape is not stable</h2>
<p>These cases are simply marked as requiring owning references:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ante" data-lang="ante"><span class="nf">get</span> <span class="p">(</span><span class="n">v</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">own</span> <span class="kt">Vec</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">index</span><span class="o">:</span> <span class="kt">Usz</span><span class="p">)</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">own</span> <span class="n">t</span> <span class="k">can</span> <span class="kt">Fail</span> <span class="ow">=</span> <span class="o">...</span>
</code></pre></div><p>This function signature states that in order to return a reference to a vector&rsquo;s elements,
it needs an owned, though immutable, reference to the Vec. Note that &ldquo;owned&rdquo; here still allows
multiple immutable references. A type is only considered to be shared when there is a mutable
reference to it and at least one other reference to it of any kind.
When we try to call <code>get</code> with a shared vector, we&rsquo;ll get an error:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ante" data-lang="ante"><span class="nf">v</span> <span class="ow">=</span> <span class="kt">Vec</span><span class="o">.</span><span class="n">of</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="nf">v_ref1</span> <span class="ow">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">v</span>
<span class="nf">v_ref2</span> <span class="ow">=</span> <span class="o">&amp;</span><span class="n">v</span>

<span class="c1">// error: Expected an owned reference, but `v_ref1` is shared</span>
<span class="nf">v_elem</span> <span class="ow">=</span> <span class="n">get</span> <span class="n">v_ref1</span> <span class="mi">3</span>

<span class="nf">print</span> <span class="n">v_ref1</span>
<span class="nf">print</span> <span class="n">v_ref2</span>
</code></pre></div><p>Similarly, if we try to explicitly grab an owned reference for <code>v_ref2</code>, we&rsquo;ll get the error there instead:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ante" data-lang="ante"><span class="nf">v</span> <span class="ow">=</span> <span class="kt">Vec</span><span class="o">.</span><span class="n">of</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="nf">v_ref1</span> <span class="ow">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">v</span>

<span class="c1">// error: Cannot borrow an owned reference, `v` is already mutably borrowed</span>
<span class="nf">v_ref2</span> <span class="ow">=</span> <span class="o">&amp;</span><span class="n">own</span> <span class="n">v</span>

<span class="nf">v_elem</span> <span class="ow">=</span> <span class="n">get</span> <span class="n">v_ref1</span> <span class="mi">3</span>

<span class="nf">print</span> <span class="n">v_ref1</span>
<span class="nf">print</span> <span class="n">v_ref2</span>
</code></pre></div><p>Taking the reference of a tagged union&rsquo;s fields also requires an owned reference, although this
must be built into the language.</p>
<hr>
<h2 id="making-shared-useful">Making Shared Useful</h2>
<p>Hold on, this is great and all, but how usable are shared references really if we can&rsquo;t do something
as common as holding onto a vector&rsquo;s elements with them? Does this mean we can&rsquo;t use a shared vector
at all?</p>
<p>No! It turns out that even on a shape-unstable type like <code>Vec t</code>, most of its functions are still
perfectly fine to use in a shared, mutable context. As long as we don&rsquo;t give out references to elements
we are fine:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ante" data-lang="ante"><span class="c1">// Reference-polymorphic, great!</span>
<span class="nf">len</span> <span class="p">(</span><span class="n">v</span><span class="o">:</span> <span class="o">&amp;</span><span class="kt">Vec</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="kt">Usz</span> <span class="ow">=</span> <span class="o">...</span>

<span class="c1">// Also great!</span>
<span class="nf">push</span> <span class="p">(</span><span class="n">v</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="kt">Vec</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">elem</span><span class="o">:</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="kt">Unit</span> <span class="ow">=</span> <span class="o">...</span>

<span class="c1">// Fantastic!</span>
<span class="nf">pop</span> <span class="p">(</span><span class="n">v</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="kt">Vec</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">t</span> <span class="k">can</span> <span class="kt">Fail</span> <span class="ow">=</span> <span class="o">...</span>
</code></pre></div><p>Alright, alright but that still never solved the issue of actually accessing the elements without
removing them from the Vec. It turns out however, we can do that too:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ante" data-lang="ante"><span class="nf">get_cloned</span> <span class="p">(</span><span class="n">v</span><span class="o">:</span> <span class="o">&amp;</span><span class="kt">Vec</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">index</span><span class="o">:</span> <span class="kt">Usz</span><span class="p">)</span> <span class="o">:</span> <span class="n">t</span> <span class="k">can</span> <span class="kt">Fail</span> <span class="k">given</span> <span class="kt">Clone</span> <span class="n">t</span> <span class="ow">=</span> <span class="o">...</span>
</code></pre></div><p>(<code>given Clone t</code> is Ante&rsquo;s way of writing trait constraints)</p>
<p>As long as we don&rsquo;t return a reference to an element, the API itself is safe.
Note that since this requires cloning each value, this will be fine for small,
primitive types, but will be expensive for vectors with more complex element types.
To work around this, we can have a vector of pointer types instead
to reduce the cost of cloning: <code>Vec (Rc MyStruct)</code>. Looks like we&rsquo;ve rediscovered why languages
like Pony, Koka, Haskell, Java, and many others box values! With this, we&rsquo;ve gone full
circle and (I think) have achieved the best of both the unboxed and boxed worlds.</p>
<hr>
<h2 id="shared-interior-mutability">Shared Interior Mutability</h2>
<p>Eagle-eyed Rust users will note that the <code>Vec (Rc MyStruct)</code> suggestion above does not have quite
the same semantics as an owned <code>Vec&lt;MyStruct&gt;</code> in Rust. Most notably, <code>Rc&lt;T&gt;</code> in Rust
(and <code>Rc t</code> in Ante) prevent mutating the inner element by only handing out immutable
references. If we want to still be able to mutate <code>MyStruct</code>, we have to resort to interior
mutability. In Rust, this can be quite loathsome. Using a type like <code>RefCell&lt;T&gt;</code> enables us
to mutate the inner value but also requires runtime checking to ensure AxM rules are upheld.
This can even cause runtime panics in our code if we get this incorrect!</p>
<p>Ante however, provides the <code>Mut t</code> type for aliasable interior mutability. Since Ante already
allows aliasable mutability, there are absoluately no runtime checks required and <code>Mut t</code>
is just a wrapper struct containing only the wrapped <code>t</code>. This, along with the lack of runtime
checks for other <code>&amp;shared mut t</code> references is what makes this scheme zero-cost.</p>
<p>The key difference with <code>Mut t</code> which makes it safe is that it can only hand out shared
mutable references:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ante" data-lang="ante"><span class="nf">as_mut</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="o">&amp;</span><span class="kt">Mut</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">shared</span> <span class="k">mut</span> <span class="n">t</span> <span class="ow">=</span> <span class="o">...</span>
</code></pre></div><p>Since <code>shared</code> references are already restricted to only operations safe to perform on references
which may be mutably aliased, we are all good to go!</p>
<p>If you ever do need interior mutability to lend out owning references, then you will still need
to resort to a <code>RefCell t</code> or similar interior mutability type inherited from Rust.</p>
<hr>
<h1 id="closing-notes">Closing Notes</h1>
<p>This was my first blog post for Ante and I&rsquo;m quite excited to share it with anyone reading.
As far as I&rsquo;m aware, when this is implemented Ante will be the first and only language with
safe, aliasable mutability and unboxed types. If you found this at all interesting, please
consider checking out the <a href="https://github.com/jfecher/ante">github page</a> and/or joining
<a href="https://discord.gg/NPJncGBAws">Ante&rsquo;s discord</a> to discuss the language. The compiler is always
open to contributions but I love just discussing the language with anyone who wants to as well.
Thanks for reading and have a fantastic day!</p>

                        </div>
                        
                        

                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://antelang.org/"><h1>Ante</h1></a>
    </div>

    
    
    
    
    <div class="table-of-contents toc bd-callout">
        
        
            
            
                
                    
                    
                    
                        <ul class="toc-h1">
                    
                    
                    
                    
                    <a href="/blog/safe_shared_mutability/#background">
                        <li>Background</li>
                    </a>
                    
                    
                        </ul>
                    
                
            
        
            
            
                
                    
                    
                    
                        <ul class="toc-h1">
                    
                    
                    
                    
                    <a href="/blog/safe_shared_mutability/#a-new-approach-for-a-new-age">
                        <li>A New Approach for A New Age</li>
                    </a>
                    
                    
                        </ul>
                    
                
            
        
            
            
                
                    
                    
                    
                        <ul class="toc-h1">
                    
                        <ul class="toc-h2">
                    
                    
                    
                    
                    <a href="/blog/safe_shared_mutability/#preventing-borrows-when-a-typeamprsquos-shape-is-not-stable">
                        <li>Preventing borrows when a type&amp;amp;rsquo;s shape is not stable</li>
                    </a>
                    
                    
                        </ul>
                    
                        </ul>
                    
                
            
        
            
            
                
                    
                    
                    
                        <ul class="toc-h1">
                    
                        <ul class="toc-h2">
                    
                    
                    
                    
                    <a href="/blog/safe_shared_mutability/#making-shared-useful">
                        <li>Making Shared Useful</li>
                    </a>
                    
                    
                        </ul>
                    
                        </ul>
                    
                
            
        
            
            
                
                    
                    
                    
                        <ul class="toc-h1">
                    
                        <ul class="toc-h2">
                    
                    
                    
                    
                    <a href="/blog/safe_shared_mutability/#shared-interior-mutability">
                        <li>Shared Interior Mutability</li>
                    </a>
                    
                    
                        </ul>
                    
                        </ul>
                    
                
            
        
            
            
                
                    
                    
                    
                        <ul class="toc-h1">
                    
                    
                    
                    
                    <a href="/blog/safe_shared_mutability/#closing-notes">
                        <li>Closing Notes</li>
                    </a>
                    
                    
                        </ul>
                    
                
            
        
    </div>
    


    <p>&copy; 2024. All rights reserved. </p>
  </div>
</div>


                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <footer id="footer">
    <div class="container">

        

        <div class="col-md-4 col-sm-6">

            
            <h4>Recent posts</h4>

            <div class="blog-entries">
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://antelang.org/blog/safe_shared_mutability/">
                          
                            <img src="/img/banners/antelope_bird.jpg" class="img-responsive" alt="Achieving Safe, Aliasable Mutability with Unboxed Types">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://antelang.org/blog/safe_shared_mutability/">Achieving Safe, Aliasable Mutability with Unboxed Types</a></h5>
                    </div>
                </div>
                
                <div class="item same-height-row clearfix">
                    <div class="image same-height-always">
                        <a href="https://antelang.org/blog/second_class_references/">
                          
                            <img src="/img/banners/anteater2.jpg" class="img-responsive" alt="Avoiding Lifetime Variables">
                          
                        </a>
                    </div>
                    <div class="name same-height-always">
                        <h5><a href="https://antelang.org/blog/second_class_references/">Avoiding Lifetime Variables</a></h5>
                    </div>
                </div>
                
            </div>

            <hr class="hidden-md hidden-lg">
            

        </div>
        

        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-right">
              Template by <a href="https://bootstrapious.com/p/universal-business-e-commerce-template">Bootstrapious</a>.
              

              Ported to Hugo by <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>.
            </p>
        </div>
    </div>
</div>





    </div>
    

    
<script src="//code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js"></script>

<script src="https://antelang.org/js/front.js"></script>


<script src="https://antelang.org/js/owl.carousel.min.js"></script>


  </body>
</html>
